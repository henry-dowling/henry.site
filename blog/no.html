<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>No code got the problem right and the solution wrong – Henry Dowling</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      line-height: 1.4;
      font-size: 16px;
      padding: 0 10px;
      margin: 50px auto;
      max-width: 650px;
    }
    #maincontent {
      max-width: 42em;
      margin: 15 auto;
    }
  </style>
</head>
<body>
  <header>
    <h1>Henry Dowling</h1>
    <nav>
      <a href="/blog.html">Home</a>
      <a href="/blog.html">Blog</a>
      <a href="/reading-list.html">Reading List</a>
    </nav>
  </header>
  <main>
    <h2>No code got the problem right and the solution wrong</h2>
    <p><strong>TLDR:</strong></p>
    <ol>
      <li>There's an irreducible amount of complexity inherent in the development of any reasonably useful piece of software</li>
      <li>Apps = boilerplate + context</li>
      <li>No-code hid too much complexity, vibe coding doesn't hide enough</li>
    </ol>
    <br>
    <p>The basic premise of no-code is to allow anyone to write software by abstracting away the boilerplate parts—setting up a db, hosting a server, building email integrations—and allowing a user to define behavior through simple UI rather than coding. <a href="https://bubble.io/blog/no-code-manifesto/">Here's</a> a piece that sums it up well.</p>
    <p>I was an early believer in this project. In 2020, I took a leave of absence from college to become a founding engineer at <a href="https://bubble.io/">Bubble</a><sup id="fnref1"><a href="#fn1">1</a></sup>. I helped to build the most powerful no-code framework in the world, used by millions of entrepreneurs.</p> 
    <p>Unfortunately, no-code hasn't really lived up to its promise. In this post I'll share some thoughts about why, and make some recommendations on how vibe-coding platforms should take inspiration from no-code.</p>
    <h3>Why did no-code not work?</h3>
    <u>Applications are complex</u>
    <ul>
      <li>There's an irreducible amount of complexity inherent to any reasonably useful piece of software.</li>
      <li>Types of complexity:
        <ul>
          <li>Product surface area (e.g. what happens when a user quits midway through onboarding after making a profile?)</li>
          <li>Real-world messiness (e.g. we need to write a separate flow for the visa application for each country)</li>
          <li>Architectural decisions (e.g. do we expect this data type to have a &gt;100 read:write ratio?)</li>
          <li>Design decisions (e.g. should this piece of UI disappear on page width &lt;1080 to make room for the rest of the page?)</li>
        </ul>
      </li>
      <li>Good <strong>abstraction design</strong> can reduce complexity. But of course, abstraction design sounds a lot like <em>coding</em>.</li>
      <li>The best way to <strong>represent</strong> a complex piece of application logic is code, not a no-code app builder UI. It's easy to ctrl-f, and it's simple to repeat bits of logic.</li>
      <li>The amount of irreducible complexity in an app is equal to the amount of <strong>context</strong> specific to that app.</li>
      <ul>
        <li>Anything in an app that's not context-dependent is <strong>boilerplate</strong>, and can be implemented by a no-code framework.</li>
      </ul>
    </ul>
    <u>Every no-code app requires custom code</u>
    <ul>
      <li>Inevitably, any app built by no-code requires some bit of logic that isn't supported out of the box by a no-code framework. Some examples:
        <ul>
          <li>How many weekdays are there in between these two dates</li>
          <li>Read from the user's clipboard</li>
          <li>Trigger for when the app goes offline</li>
        </ul>
      </li>
      <li>Related: every no-code app inevitably requires an integration with a third-party vendor that isn't supported out-of-the box by no-code.</li>
      <li>AI can mostly fix this problem.</li>
    </ul>
    <u>There's a steep learning curve</u>
    <ul>
      <li>Learning how to code is hard; learning how to no-code is easier but not <em>that much </em> easier. As we saw above, some complexity is inherent to software. Any software builder needs to learn concepts like relational databases, responsiveness, interfaces and APIs to have a reasonable shot at success. This takes a while.</li>
      <li>The value prop of learning a no-code framework is made less appealing by the perception that the knowledge won't transfer off-platform, unlike coding.</li>
    </ul>
    <u>Vibe-coding is a much better experience</u>
    <ul>
      <li>AI solves many of the above problems. It be fed information about an application and make reasonable design decisions to handle the context-specific complexity. It can write custom code for logic not covered by no-code frameworks. And it delivers results instantly.</li>
    </ul>
    <h3>What can we learn from no-code?</h3>
    <h4>Keep</h4>
    <ol>
      <li>Abstracting away the true boilerplate complexity of building software.
        <ol type="a">
          <li>Software is context + boilerplate. There's a <em>lot</em> of boilerplate inherent to software development still— e.g. package management, secrets management, hosting, security.</li>
          <li>Current SOTA "vibe coding" tools are substantially behind on achieving this goal compared to the best no-code tools.</li>
        </ol>
      </li>
      <li>Visual WISYWIG editing
        <ol type="a">
          <li>It's easier to create pixel perfect designs with a figma-like editor than by prompting a chat window.</li>
          <li>The highest-throughput communication medium for visuals is visuals, not descriptions of designs.</li>
        </ol>
      </li>
    </ol>
    <h4>Leave behind</h4>
    <ol>
      <li>Hiding implementations
        <ol type="a">
          <li>It was a bad idea to hide implementations of things like "send email". This was done in the name of simplicity, but in fact inevitably causes hidden undefined behavior.</li>
        </ol>
      </li>
      <li>New frameworks and languages
        <ol type="a">
          <li>AI has ensured that the most popular web frameworks (Node/React) will increase in popularity.</li>
          <li>AI is able to build Node/React apps more effectively than other stacks due to the abundance of training data. This ensures that in the future, a higher proportion of apps will be built with Node/React, which will further improve AI's differential effectiveness on this stack.</li>
        </ol>
      </li>
    </ol>
  </main>
  <footer>
    <hr>
    <ol style="font-size: 0.9em;">
      <li id="fn1">I got the job by cold-emailing the <a href="http://blog.joshhaas.com/" target="_blank" rel="noopener noreferrer">CEO</a>. <a href="#fnref1">↩</a></li>
    </ol>
    © <script>document.write(new Date().getFullYear());</script> Henry Dowling
  </footer>
</body>
</html> 