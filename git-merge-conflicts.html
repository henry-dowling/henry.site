<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>How Git decides when there's a merge conflict – Henry Dowling</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/jpeg" href="favicon.jpg">
  <style>
    body {
      line-height: 1.4;
      font-size: 16px;
      padding: 0 10px;
      margin: 50px auto;
      max-width: 650px;
    }
    #maincontent {
      max-width: 42em;
      margin: 15 auto;
    }
    pre {
      background: #f7f7f7;
      padding: 10px;
      overflow: auto;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
    }
    .code-comparison {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }
    .code-comparison pre {
      flex: 1;
      margin: 0;
    }
    .code-block {
      display: flex;
      flex-direction: column;
    }
    .code-caption {
      font-size: 0.9em;
      font-weight: 600;
      color: #666;
      margin-bottom: 8px;
      text-align: center;
    }
    @media (max-width: 768px) {
      .code-comparison {
        flex-direction: column;
        gap: 10px;
      }
    }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
</head>
<body>
  <header>
    <h2><a href="index.html" style="color: inherit; text-decoration: none;">Henry Dowling</a>'s <a href="blog.html">Blog</a></h2>
  </header>
  <main>
    <h2>How Git decides when there's a merge conflict</h2>
    <p style="color:#666; margin-top:-10px;">October 18, 2025</p>

    <p>After working through a merge conflict, Sam asked me “how does Git decide when there’s a merge conflict versus just automerging anyway?” I was annoyed that I couldn’t give a simple answer, so I looked it up and here it is:</p>

    <h3>The basics</h3>
    <p>When you merge two branches, Git performs a three-way merge. This just means it constructs a new merge-specific working tree by walking three trees in parallel: branch A, branch B, and their common ancestor (the base). Whenever it reaches a file where the blob hashes differ between any of the three trees, it applies this rule of thumb:</p>
    <p>For every line in the base... </p> 
    <ul>
      <li><strong>If exclusively A or B changes the line</strong>, keep that side’s change (no conflict).</li>
      <li><strong>If both A and B change the line</strong>, declare a merge conflict.</li>
    </ul>

    <p>Here's an example where we keep A's change (left) versus where Git declares a conflict (right):</p>
    <div class="code-comparison">
      <div class="code-block">
        <div class="code-caption">Take A's changes</div>
        <pre><code class="language-python"># Base
print("hello world")
print("A")
print("B")
print("C")

# A
print("hello world")
<mark>print("DOG")</mark>
print("B")
print("C")

# B
print("hello world")
print("A")
print("B")
print("C")
</code></pre>
      </div>
      <div class="code-block">
        <div class="code-caption">Merge conflict :(</div>
        <pre><code class="language-python"># Base
print("hello world")
print("A")
print("B")
print("C")

# A
print("hello world")
<mark>print("DOG")</mark>
print("B")
print("C")

# B
print("hello world")
<mark>print("CAT")</mark>
print("B")
print("C")
</code></pre>
      </div>
    </div>

    <p>And that's it! Pretty simple. </p>

    <b> But wait, what about adding new lines? Deleting lines? Moving lines?</b>
    <p> Okay, I’ve been slightly lying to you so far. The actual thing that git checks isn’t whether two edits are made to the <em>same line</em>, but whether the patches A and B have any <mark><em>overlapping hunks</em></mark>. </p>

    <h3>Hunks</h3>
    <p>Now we need to introduce the concept of <em>hunks</em>. Hunks actually come from <em>diff algorithms</em>, not Git itself. By default Git uses the <a href=https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/>Myers' algorithm</a>.<sup id="fnref2"><a href="#fn2">2</a></sup></p> 
    <p>See <a href=https://www.gnu.org/software/diffutils/manual/html_node/Hunks.html>here</a> for a great explanation of what a hunk is. A <em>hunk</em> is a contiguous group of changed lines in a diff, optionally surrounded by some context lines for human readability.</p>

    <p>We can write the diff between any two files as:
        
        <ul>
            <li>
              <strong> Diff = Blocks where the two files are the same + Blocks where the two files differ </strong>
            </li>
          </ul>
        
    
    We call the second term—each of the discrete blocks where the files differ—<em>hunks</em>. The example below has two hunks: </p>

    <div class="code-comparison">
      <div class="code-block">
        <div class="code-caption">File A</div>
        <pre><code class="language-python">print("A")
<mark>print("DOG")</mark>
print("B")
<mark>print("RED")</mark>
print("D")</code></pre>
      </div>
      <div class="code-block">
        <div class="code-caption">File B</div>
        <pre><code class="language-python">print("A")
<mark>print("CAT")</mark>
print("B")
<mark>print("BLUE")</mark>
print("D")</code></pre>
      </div>
    </div>
    
    <div class="code-block">
      <div class="code-caption">Diff (conceptually)</div>
      <pre><code class="language-plaintext">Same: print("A")
Hunk 1: { <mark>print("DOG")</mark> ↔ <mark>print("CAT")</mark> }
Same: print("B")
Hunk 2: { <mark>print("RED")</mark> ↔ <mark>print("BLUE")</mark> }
Same: print("D")</code></pre>
    </div>

    <h3>Hunks depend on diff algorithm</h3>
    <p>I said earlier that hunks come from diff algorithms. Here's something surprising: two different diff algorithms can yield <u>two different sets of hunks</u> for a given set of files.<sup id="fnref3"><a href="#fn3">3</a></sup></p>

    <p>Suppose the file F contains the three lines 'a', 'b', 'c', and the file G contains the same three lines in reverse order: 'c', 'b', 'a'. If diff finds the line 'c' as common, then the command 'diff F G' produces this output:</p>
    <div class="code-block">
      <div class="code-caption">Diff output (common line 'c')</div>
      <pre><code class="language-diff">1,2d0
&lt; a
&lt; b
3a2,3
&gt; b
&gt; a
</code></pre>
    </div>
    <p>But if diff notices the common line 'b' instead, it produces this output:</p>
    <div class="code-block">
      <div class="code-caption">Diff output (common line 'b')</div>
      <pre><code class="language-diff">1c1
&lt; a
---
&gt; c
3c3
&lt; c
---
&gt; a
    </code></pre>
    </div>

    <p>There are many different ways for a diff algorithm to decide on which hunks to use to represent the diff between two files, and it’s up to the diff algorithm to make hunks minimal and readable to make life easier for the reviewer.<sup id="fnref1"><a href="#fn1">1</a></sup></p>

    <h3>Hunks in Git’s merge algorithm</h3>

    


    <p>Now we can state Git’s real decision procedure more precisely:</p>
    <ol>
      <li>Compute patches <code>base → A</code> and <code>base → B</code>.</li>
      <li>If any hunks from those two patches overlap, Git marks a merge conflict for those regions; otherwise it applies both.</li>
    </ol>

    <p>Example:</p>
    <div class="code-block">
      <div class="code-caption">Overlapping hunks example</div>
      <pre><code class="language-diff"># Base
print("hello world")
print("A")
print("B")
print("C")

# Commit A
print("hello world")
<mark>print("DOG")</mark>
print("B")
print("C")

diff A (e.g. `git diff base..A`):
@@ -1,4 +1,5 @@
 print("hello world")
 print("A")
+<mark>print("DOG")</mark>
 print("B")
 print("C")
 \ No newline at end of file

# Commit B
print("hello world")
<mark>print("CAT")</mark>
print("B")
print("C")

diff B:
@@ -1,4 +1,5 @@
 print("hello world")
 print("A")
+<mark>print("CAT")</mark>
 print("B")
 print("C")
 \ No newline at end of file
</code></pre>
    </div>

    <p>Here the hunks overlap, so Git reports a conflict.</p>

    <h3>Wait, but what does it mean for hunks to overlap?</h3>

    <p>Each hunk can be represented as <code>(old_start, old_length, new_start, new_length)</code> — this is the <code>@@ -a,b +c,d @@</code> header you see in unified diffs. To compare A and B, use their coordinates relative to the <em>base</em> (the “old” ranges), since the base is a common reference. Two hunks overlap if their old-range intervals intersect.</p>

    <p>One subtlety: the printed hunk windows include a couple lines of <em>context</em> for human readability (configurable in Git). Even if two printed hunk windows visually touch or overlap due to context, the <em>actual change ranges</em> may not, in which case Git can still auto-merge.</p>

    <p>Concrete illustration (non-overlapping actual changes even though context suggests proximity):</p>
    <div class="code-block">
      <div class="code-caption">Non-overlapping hunks example</div>
      <pre><code class="language-diff">@@ -1,4 +1,5 @@
print("hello world")
print("A")
+<mark>print("DOG")</mark>
print("B")
print("C")
\ No newline at end of file

@@ -1,4 +1,5 @@
print("hello world")
print("A")
print("B")
+<mark>print("CAT")</mark>
print("C")
\ No newline at end of file

Base:
print("hello world")
print("A")
print("B")
print("C")
</code></pre>
    </div>

    <p>Here, the true change ranges don’t intersect (one inserts between A and B; the other between B and C), so Git can merge automatically even though the displayed context might make them look adjacent.</p>

    <h3>Special cases</h3>
    <ul>
      <li>File rename conflicts</li>
      <li>Deleting + editing a file</li>
    </ul>
    <p>These follow additional rules and are less interesting for the basic overlapping-hunks intuition.</p>

    <hr>
    <section id="footnotes" aria-label="Footnotes">
      <ol style="font-size:0.95em; color:#555; padding-left: 1.2em; margin-top: 1em;">
        <li id="fn1">This has implications for codebase analytics too- your PR that GitHub says was +124 -28 lines may not actually be +124 -28 when using a different diff algorithm! <a href="#fnref1" aria-label="Back to content">↩</a></li>
        <li id="fn2">if you're a nerd you can manually choose which diff algorithm you want Git to use in .gitattributes. <a href="#fnref2" aria-label="Back to content">↩</a></li>
        <li id="fn3">This example is taken from <a href="https://www.gnu.org/software/diffutils/manual/html_node/Hunks.html">the GNU diffutils docs</a>. <a href="#fnref3" aria-label="Back to content">↩</a></li>
      </ol>
    </section>

  </main>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/diff.min.js" defer></script>
  <script>document.addEventListener('DOMContentLoaded',function(){ if (window.hljs) { hljs.highlightAll(); } });</script>
</body>
</html>

