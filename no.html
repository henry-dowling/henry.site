<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>No Code Got the Problem Right and the Solution Wrong – Henry Dowling</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      line-height: 1.4;
      font-size: 16px;
      padding: 0 10px;
      margin: 50px auto;
      max-width: 650px;
    }
    #maincontent {
      max-width: 42em;
      margin: 15 auto;
    }
  </style>
</head>
<body>
  <header>
    <h2><a href="index.html" style="color: inherit; text-decoration: none;">Henry Dowling</a>'s <a href="blog.html">Blog </a></h2>
  </header>
  <main>
    <h2>No code got the problem right and the solution wrong</h2>
    <p><strong>TLDR:</strong></p>
    <ol>
      <li>There's an irreducible amount of complexity inherent in the development of any reasonably useful piece of software</li>
      <li>Apps = boilerplate + context</li>
      <li>No-code hid too much complexity, vibe coding doesn't hide enough</li>
    </ol>
    <br>
    <p>The basic premise of no-code is to allow anyone to write software by abstracting away the boilerplate parts—setting up a db, hosting a server, wiring up email—and letting users define behaviour through a simple UI rather than code. (See  <a href="https://bubble.io/blog/no-code-manifesto/">here</a>)</p>
    <p>I was an early believer. In 2020, I took a leave of absence from college to become a founding engineer at <a href="https://bubble.io/">Bubble</a><sup id="fnref1"><a href="#fn1">1</a></sup>. I helped to build the most powerful no-code framework on the planet, used by millions of entrepreneurs.</p> 
    <p>Unfortunately, no-code hasn't really lived up to its promise. In this post I'll share some thoughts about why, and make some recommendations on how vibe-coding platforms should take inspiration from no-code.</p>
    <h3>Why did no-code not work?</h3>
    <u>Applications are complex</u>
    <ul>
      <li>There's an irreducible amount of complexity inherent to any reasonably useful piece of software.</li>
      <li>Types of complexity:
        <ul>
          <li><b>Product surface area </b>e.g. what happens when a user quits midway through onboarding after making a profile?</li>
          <li> <b>Real-world messiness</b> e.g. we need to write a separate flow for the visa application for each country</li>
          <li> <b>Architectural decisions</b> e.g. do we expect this data type to have a &gt;100 read:write ratio?</li>
          <li> <b>Design decisions</b> e.g. should this piece of UI disappear on page width &lt;1080 to make room for the rest of the page?</li>
        </ul>
      </li>
      <li>Good <strong>abstraction design</strong> reduces complexity. But abstraction design is basically <em>coding</em>.</li>
      <li>The best way to <strong>represent</strong> a complex piece of application logic is code, not a no-code app builder UI. It's easy to ctrl-f, repeat logic, and source-control.</li>
      <li>The amount of irreducible complexity in an app is equal to the amount of <strong>context</strong> specific to that app.</li>
      <ul>
        <li>Anything in an app that's not context-dependent is <strong>boilerplate</strong>, and can (should) be implemented by a no-code framework.</li>
      </ul>
    </ul>
    <u>Every no-code app requires custom code</u>
    <ul>
      <li>Inevitably, any app built by no-code requires some bit of logic that isn't supported out of the box by a no-code framework. Some examples:
        <ul>
          <li>How many weekdays are there in between these two dates</li>
          <li>Read from the user's clipboard</li>
          <li>Trigger for when the app goes offline</li>
        </ul>
      </li>
      <li>Related: every no-code app inevitably requires an <b>integration</b> with a third-party vendor that isn't supported out-of-the box by no-code.</li>
      <li>AI can mostly fix this problem.</li>
    </ul>
    <u>There's a steep learning curve</u>
    <ul>
      <li>Learning how to code is hard; learning how to no-code is easier but not <em>that much </em> easier. As we saw above, some complexity is inherent to software. Any software builder needs to learn concepts like relational databases, responsiveness, interfaces and APIs to have a reasonable shot at success. This takes a while.</li>
      <li>The value prop of learning a no-code framework is made less appealing by the perception that the knowledge won't transfer off-platform, unlike coding.</li>
    </ul>
    <u>Vibe-coding is a much better experience</u>
    <ul>
      <li>AI solves many of the above problems. It be fed information about an application and make reasonable design decisions to handle the context-specific complexity. It can write custom code for logic not covered by no-code frameworks. And it delivers results instantly.</li>
    </ul>
    <h3>Learnings from no-code</h3>
    <h4>Keep</h4>
    <ol>
      <li>Abstracting away the true boilerplate complexity of building software.
        <ol type="a">
          <li>Software is context + boilerplate. There's a <em>lot</em> of boilerplate inherent to software development still— e.g. package management, secrets management, hosting, security.</li>
          <li>Current SOTA "vibe coding" tools lag behind no-code frameworks on this dimension.</li>
        </ol>
      </li>
      <li>Visual WYSIWYG editing
        <ol type="a">
          <li>It's easier to create pixel perfect designs with a figma-like editor than by prompting a chat window.</li>
          <li>The highest-throughput communication medium for visuals is visuals, not descriptions of designs.</li>
        </ol>
      </li>
    </ol>
    <h4>Leave behind</h4>
    <ol>
      <li>Hiding implementations
        <ol type="a">
          <li>It was a bad idea to hide implementations of things like "send email". This was done in the name of simplicity, but in fact inevitably causes hidden undefined behavior.</li>
        </ol>
      </li>
      <li>New frameworks and languages
        <ol type="a">
          <li>AI builds Node/React apps better because the training data is abundant; popularity begets more data, which begets better AI performance and greater usage. </li>
        </ol>
      </li>
    </ol>
  </main>
  <footer>
    <hr>
    <ol style="font-size: 0.9em;">
      <li>The irony of the name was not lost on us.</li>
    </ol>
  </footer>
</body>
</html> 